# 算法与数据结构

## 数组

### 时间复杂度

- 插入/删除 O(n)
- 随机查找 O(1)

### 数组的实现

- Java 源码分析（ArrayList）

## 链表

### 链表时间复杂度

注意这里

- 插入/删除 O(1)
- 随机查找 O(n)

### 链表分类

- 单链表
- 双向链表

	- java中实现的LinkedList是双向链表
	- LRU 缓存机制

- 循环链表
- 跳表

	- 使用条件: 只能用于链表里的元素有序的情况
	- 对标: 跳表对标的是平衡树(AVL Tree)和二分查找
	- 复杂度

		- 时间复杂度

			- 插入删除搜索都是O(logn)

		- 空间复杂度

			- O(n)

	- 优势

		- 原理简单，容易实现，方便拓展，效率更高

	- 应用

		- 在一些热门项目中用来替代平衡树，如 redis levelDB

	- 核心思想

		- 升维思想+空间换时间

## 栈 stack

### 特点

- 先入后出,只能在栈顶出入

### 时间复杂度

- 入栈和出栈都是O(1),查询O(n)

### java中推荐使用deque代替stack

## 队列 queue

### 特点

- 先入先出，队头出，队尾入

### 时间复杂度

- 入队和出队都是O(1),查询O(n))

### 队列分类

- 双端队列(deque)

	- 两端都可以进和出

- 优先队列(PriorityQueue)

	- 时间复杂度

		- 插入O(1)
		- 取出操作O(logn),可以按照元素的优先级取出

	- 底层实现:heap,bst,treap

## 哈希表(散列表)

### 定义: 是根据关键码值(Key value )而直接进行访问的数据结构,其实就是根据hash函数计算出来它的数组下标,然后进行访问

### 时间复杂度

- 平均增删查是O(1)
- 最坏是O(n),发生哈希碰撞后退化为一个链表

### 工程中的应用

- MAP

	- java中的实现

		- HashMap

			- 用于非线程安全场景,线程安全的场合可以用ConcurrentHashMap替换

		- Hashtable

			- 线程安全,任一时间只有一个线程能写Hashtable,并发差

		- LinkedHashMap

			- LinkedHashMap是HashMap的一个子类

		- TreeMap

			- TreeMap实现SortedMap接口,如果使用排序的映射，建议使用TreeMap

- SET

	- java 中的实现

		- hashset

			-  底层是hashmap

##  树tree

### 树与链表

- 当链表有next指向两个节点的时候就变成了树，所以链表是特殊化的树

### 树与图

- 树与图最大差别是是否有环，当有环时树就变成了图，所以树是特殊话的图

### 树的分类

- 二叉树

	-  定义: 二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树
	- 满二叉树

		- 定义: 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树

	- 完全二叉树

		- 定义:一个深度为k,节点个数为2^k-1的二叉树为满二叉树,其实就是一棵树每层从左往右编号，不能中断编号

	- 遍历: 根据相对根的位置进行遍历

		- 前序:  根左右
		- 中序: 左根右
		- 后序: 左右根

	- 二叉搜索树Binary Search Tree

		- 二叉搜索树，也称二叉排序树、有序二叉树(Ordered Binary Tree)、排 序二叉树(Sorted Binary Tree)
		- 定义: 是指一棵空树或者具有下列性质的二叉树:
1. 左子树上所有结点的值均小于它的根结点的值;
2. 右子树上所有结点的值均大于它的根结点的值;
3. 以此类推:左、右子树也分别为二叉查找树。 (这就是 重复性!)
		- 中序遍历:升序排列
		- 常见操作

			- 查询
			- 插入新结点
			- 删除

		- 时间复杂度

			- 常见操作都是O(logn)
			- 特殊情况变成一根棍子的情况, 是O(n)

### 树算法解决问题的思路一般都是递归

## 堆heap

###    定义: 可以迅速找到一堆数中的最大值或最小值的数据结构

### 分类 

- 大顶堆: 根节点最大的堆
-  小顶堆: 根节点最小的堆

### 时间复杂度

- find-max: O(1)
- delete-max: O(logn)
- insert(create): O(logn) or O(1) 

### 常见的堆: 二叉堆，斐波那契堆

### 二叉堆

-   性质

	- 通过完全二叉树来实现
	- 是一颗完全二叉树
	- 树中任意节点的值总是>=其子节点的值

- 实现

	-  二叉堆一般通过数组来实现的
	-    插入 

		- 新元素一律先插入到堆的尾部
		- 依次向上调整整个堆的结构（一直到根即可）

	- Delete Max 删除堆顶项操作

		-  将堆尾元素替换到顶部(即对顶被代替删除掉)
		-  依次从根部向下调整整个堆的结构(一直到堆尾即可)

## 图graph

## 算法核心思想

### 升维,即将一维升二维乃至更高维

## 查找对应数据结构在高级语言中的实现

### 查询接口文档

- google 搜索: stack java 8

### 查询源码实现

- java8 stack source code
- java8 stack source code  download

*XMind: ZEN - Trial Version*