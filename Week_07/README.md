# 算法与数据结构

## 算法核心思想

### 升维,即将一维升二维乃至更高维

## 查找对应数据结构在高级语言中的实现

### 查询接口文档

- google 搜索: stack java 8

### 查询源码实现

- java8 stack source code
- java8 stack source code  download

## 数组

### 时间复杂度

- 插入/删除 O(n)
- 随机查找 O(1)

### 数组的实现

- Java 源码分析（ArrayList）

## 链表

### 链表时间复杂度

注意这里

- 插入/删除 O(1)
- 随机查找 O(n)

### 链表分类

- 单链表
- 双向链表

	- java中实现的LinkedList是双向链表
	- LRU 缓存机制

- 循环链表
- 跳表

	- 使用条件: 只能用于链表里的元素有序的情况
	- 对标: 跳表对标的是平衡树(AVL Tree)和二分查找
	- 复杂度

		- 时间复杂度

			- 插入删除搜索都是O(logn)

		- 空间复杂度

			- O(n)

	- 优势

		- 原理简单，容易实现，方便拓展，效率更高

	- 应用

		- 在一些热门项目中用来替代平衡树，如 redis levelDB

	- 核心思想

		- 升维思想+空间换时间

## 栈 Stack

### 特点

- 先入后出,只能在栈顶出入

### 时间复杂度

- 入栈和出栈都是O(1),查询O(n)

### java中推荐使用deque代替stack

## 队列 queue

### 特点

- 先入先出，队头出，队尾入

### 时间复杂度

- 入队和出队都是O(1),查询O(n))

### 队列分类

- 双端队列(deque)

	- 两端都可以进和出

- 优先队列(PriorityQueue)

	- 时间复杂度

		- 插入O(1)
		- 取出操作O(logn),可以按照元素的优先级取出

	- 底层实现:heap,bst,treap

## 哈希表(散列表)

### 定义: 是根据关键码值(Key value )而直接进行访问的数据结构,其实就是根据hash函数计算出来它的数组下标,然后进行访问

### 时间复杂度

- 平均增删查是O(1)
- 最坏是O(n),发生哈希碰撞后退化为一个链表

### 工程中的应用

- MAP

	- java中的实现

		- HashMap

			- 用于非线程安全场景,线程安全的场合可以用ConcurrentHashMap替换

		- Hashtable

			- 线程安全,任一时间只有一个线程能写Hashtable,并发差

		- LinkedHashMap

			- LinkedHashMap是HashMap的一个子类

		- TreeMap

			- TreeMap实现SortedMap接口,如果使用排序的映射，建议使用TreeMap

- SET

	- java 中的实现

		- hashset

			- 底层是hashmap

## 树tree

### 树与链表

- 当链表有next指向两个节点的时候就变成了树，所以链表是特殊化的树

### 树与图

- 树与图最大差别是是否有环，当有环时树就变成了图，所以树是特殊话的图

### 树的分类

- 二叉树

	- 定义: 二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树
	- 满二叉树

		- 定义: 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树

	- 完全二叉树

		- 定义:一个深度为k,节点个数为2^k-1的二叉树为满二叉树,其实就是一棵树每层从左往右编号，不能中断编号

	- 遍历: 根据相对根的位置进行遍历

		- 前序:  根左右
		- 中序: 左根右
		- 后序: 左右根

	- 二叉搜索树Binary Search Tree

		- 二叉搜索树，也称二叉排序树、有序二叉树(Ordered Binary Tree)、排 序二叉树(Sorted Binary Tree)
		- 定义: 是指一棵空树或者具有下列性质的二叉树:

			- 1. 左子树上所有结点的值均小于它的根结点的值;
			- 2. 右子树上所有结点的值均大于它的根结点的值;
			- 3. 以此类推:左、右子树也分别为二叉查找树。 (这就是 重复性!) 中序遍历:升序排列


		- 常见操作

			- 查询
			- 插入新结点
			- 删除
			- 常见操作都是O(logn)，特殊情况变成一根棍子的情况, 是O(n)

- 平衡树

  为了解决树的平衡，而引入的树

	- AVL

		- 平衡因子 Balance Factor

			- 它的左子树的高度减去它的右子树的高度(有时相反) balance factor={-1,0,1}，即绝对值小于等于1

		- 旋转操作

			- 左旋

				- 右右子树

			- 右旋

				- 左左子树

			- 左右旋

				- 左右子树

			- 右左旋

				- 右左子树

- 红黑树

  因为AVL树的插入和删除需要维护树的次数比较频繁，为此引入近似平衡的二叉树，红黑树

	- 红黑树是一种近似平衡的二叉搜索树(Binary Search Tree)，它能够确保任何一 个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉 搜索树

		- 每个结点要么是红色，要么是黑色
		- 根结点是黑色
		- 每个叶结点(NIL结点，空结点)是黑色的
		- 不能有相邻接的两个红色结点
		- 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

	- 关键性质

		- 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长

- AVL与红黑树的对比

	- AVL比红黑树的查找更快，因为它是严格平衡的二叉树
	- 红黑树比AVL树的插入和删除更快,因为它相对宽松的平衡减少了旋转 
	- AVL树存储每个节点的平衡因子或高度，因此每个节点需要存储一个整数，而红黑树每个节点只需要1位信息。
	- 红黑树中使用的大多数语言库如java的map和set中，而AVL树使用数据库中快速检索是必需的。

### 树算法解决问题的思路一般都是递归

- 节点的定义
- 重复性(自相似性)

## 堆heap

### 定义: 可以迅速找到一堆数中的最大值或最小值的数据结构

### 分类

- 大顶堆: 根节点最大的堆
- 小顶堆: 根节点最小的堆

### 时间复杂度

- find-max: O(1)
- delete-max: O(logn)
- insert(create): O(logn) or O(1)

### 常见的堆: 二叉堆，斐波那契堆

### 二叉堆

- 性质

	- 通过完全二叉树来实现
	- 是一颗完全二叉树
	- 树中任意节点的值总是>=其子节点的值

- 实现

	- 二叉堆一般通过数组来实现的
	- 插入
	- 新元素一律先插入到堆的尾部
	- 依次向上调整整个堆的结构（一直到根即可）
	- Delete Max 删除堆顶项操作

		- 将堆尾元素替换到顶部(即对顶被代替删除掉)
		- 依次从根部向下调整整个堆的结构(一直到堆尾即可)

## 图graph

## 递归

### 理解例子

- 从前有个山
- 盗梦空间

### 递归模板

### 思维要点

- 不要人肉进行递归(最大误区)
- 找到最近最简方法，将其拆解成可重复解决的问题(重复子问题)
- 数学归纳法思维

### 分治

- 重复性
- 分治代码模板

### 动态规划

- 递归或者分治 没有根本上的区别

	- 关键看有无最优的子结构
	- 共性:找到重复子问题
	- 差异性:最优子结构、中途可以淘汰次优解

- 做题步骤

	- 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)
	- 储存中间状态:opt[i]
	-  递推公式(美其名曰:状态转移方程或者 DP 方程)

		-  Fib: opt[i] = opt[n-1] + opt[n-2]
		- 二维路径:opt[i,j] = opt[i+1][j] + opt[i][j+1] (且判断a[i,j]是否空地)

- 理解

	- 动态规划就是动态递推
	- 注意用升维思想解决问题

### 回溯

- 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。
- 实现

	- 递归

- 回溯模板=递归模板+恢复原状态

  result = []
  def backtrack(路径, 选择列表):
      if 满足结束条件:
          result.add(路径)
          return
      for 选择 in 选择列表:
          做选择(是否已经选过了)
          backtrack(路径, 选择列表)
          撤销选择

### DFS(深度优先遍历)

DFS模板跟递归模板类似

public void dfs(TreeNode root) {
      //1. 递归终止条件判断    
    if(root == null) return null;
    //2. 本层逻辑处理  
        result.add(root.val);
    //3.  跳转到下一层
        dfs(root.left,result);
        dfs(root.right,result);
    //4. 本层数据状态重置
}

### BFS(广度优先遍历)

public void bfs(TreeNode root) {
        //边界条件判断
        if (root == null) {
            return ret;
        }
        //声明存储节点的queue 先进先出
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        //将第一个节点入队
        queue.offer(root);
        //如果处理当前层的队列,不为空时
        while (!queue.isEmpty()) {
            //出队并对node做处理
            TreeNode node = queue.poll();
            //将下一层左子树的元素存入队列
            if (node.left != null) {
                queue.offer(node.left);
            }
            //将下一层右子树的元素存入队列
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }

## 贪心算法

### 贪心算法是在每一步都找到局部最优解从而是整体到达最优解

对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案,一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心
法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题

### 与动态规划的区别: 它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

### 解决的常见问题: 图中的最小生成树、求哈夫曼编码等

### 适用场景

- 简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构

## 二分法

### 使用前提

- 目标函数单调性(单调递增或递减)
- 存在上下界
- 能够通过索引访问

### 算法模板

public boolean dichotomy(int[] nums,int target){
    int left =0;
    int right = nums.length-1;
    while (left<=right){
        int mid = (left+right)/2;
        if (nums[mid]==target){
            return true;
        }else if(nums[mid]<target){
            left = mid+1;
        }else {
            right=mid-1;
        }
    }
    return false;
}

### 注意点

- 边界条件的判断

## Trie树(字典树)

### 是一种树形结 构。典型应用是用于统计和排 序大量的字符串(但不仅限于 字符串)，所以经常被搜索引 擎系统用于文本词频统计

### 优点

- 最大限度地减少无谓的字符串比较，查询效率
比哈希表高。

### 基本性质

- 结点本身不存完整单词;
- 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的 字符串
- 每个结点的所有子结点路径代表的字符都不相同

### 核心思想

- 空间换时间
- 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

## 并查集

### 适用于组团、配对问题

### 基本操作

- makeSet(s):建立一个新的并查集，其中包含 s 个单元素集合。
- unionSet(x, y):把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。
- find(x):找到元素 x 所在的集合的代表，该操作也可以用于判断两个元 素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。

*@zf*