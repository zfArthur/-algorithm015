# 算法与数据结构

## 算法核心思想

### 升维,即将一维升二维乃至更高维

## 查找对应数据结构在高级语言中的实现

### 查询接口文档

- google 搜索: stack java 8

### 查询源码实现

- java8 stack source code
- java8 stack source code  download

## 数组

### 时间复杂度

- 插入/删除 O(n)
- 随机查找 O(1)

### 数组的实现

- Java 源码分析（ArrayList）

## 链表

### 链表时间复杂度

注意这里

- 插入/删除 O(1)
- 随机查找 O(n)

### 链表分类

- 单链表
- 双向链表

	- java中实现的LinkedList是双向链表
	- LRU 缓存机制

- 循环链表
- 跳表

	- 使用条件: 只能用于链表里的元素有序的情况
	- 对标: 跳表对标的是平衡树(AVL Tree)和二分查找
	- 复杂度

		- 时间复杂度

			- 插入删除搜索都是O(logn)

		- 空间复杂度

			- O(n)

	- 优势

		- 原理简单，容易实现，方便拓展，效率更高

	- 应用

		- 在一些热门项目中用来替代平衡树，如 redis levelDB

	- 核心思想

		- 升维思想+空间换时间

## 栈 Stack

### 特点

- 先入后出,只能在栈顶出入

### 时间复杂度

- 入栈和出栈都是O(1),查询O(n)

### java中推荐使用deque代替stack

## 队列 queue

### 特点

- 先入先出，队头出，队尾入

### 时间复杂度

- 入队和出队都是O(1),查询O(n))

### 队列分类

- 双端队列(deque)

	- 两端都可以进和出

- 优先队列(PriorityQueue)

	- 时间复杂度

		- 插入O(1)
		- 取出操作O(logn),可以按照元素的优先级取出

	- 底层实现:heap,bst,treap

## 哈希表(散列表)

### 定义: 是根据关键码值(Key value )而直接进行访问的数据结构,其实就是根据hash函数计算出来它的数组下标,然后进行访问

### 时间复杂度

- 平均增删查是O(1)
- 最坏是O(n),发生哈希碰撞后退化为一个链表

### 工程中的应用

- MAP

	- java中的实现

		- HashMap

			- 用于非线程安全场景,线程安全的场合可以用ConcurrentHashMap替换

		- Hashtable

			- 线程安全,任一时间只有一个线程能写Hashtable,并发差

		- LinkedHashMap

			- LinkedHashMap是HashMap的一个子类

		- TreeMap

			- TreeMap实现SortedMap接口,如果使用排序的映射，建议使用TreeMap

- SET

	- java 中的实现

		- hashset

			- 底层是hashmap

## 树tree

### 树与链表

- 当链表有next指向两个节点的时候就变成了树，所以链表是特殊化的树

### 树与图

- 树与图最大差别是是否有环，当有环时树就变成了图，所以树是特殊话的图

### 树的分类

- 二叉树

	- 定义: 二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树
	- 满二叉树

		- 定义: 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树

	- 完全二叉树

		- 定义:一个深度为k,节点个数为2^k-1的二叉树为满二叉树,其实就是一棵树每层从左往右编号，不能中断编号

	- 遍历: 根据相对根的位置进行遍历

		- 前序:  根左右
		- 中序: 左根右
		- 后序: 左右根

	- 二叉搜索树Binary Search Tree

		- 二叉搜索树，也称二叉排序树、有序二叉树(Ordered Binary Tree)、排 序二叉树(Sorted Binary Tree)
		- 定义: 是指一棵空树或者具有下列性质的二叉树:

			- 1. 左子树上所有结点的值均小于它的根结点的值;
			- 2. 右子树上所有结点的值均大于它的根结点的值;
			- 3. 以此类推:左、右子树也分别为二叉查找树。 (这就是 重复性!) 中序遍历:升序排列


		- 常见操作

			- 查询
			- 插入新结点
			- 删除
			- 常见操作都是O(logn)，特殊情况变成一根棍子的情况, 是O(n)

### 树算法解决问题的思路一般都是递归

- 节点的定义
- 重复性(自相似性)

## 堆heap

### 定义: 可以迅速找到一堆数中的最大值或最小值的数据结构

### 分类

- 大顶堆: 根节点最大的堆
- 小顶堆: 根节点最小的堆

### 时间复杂度

- find-max: O(1)
- delete-max: O(logn)
- insert(create): O(logn) or O(1)

### 常见的堆: 二叉堆，斐波那契堆

### 二叉堆

- 性质

	- 通过完全二叉树来实现
	- 是一颗完全二叉树
	- 树中任意节点的值总是>=其子节点的值

- 实现

	- 二叉堆一般通过数组来实现的
	- 插入
	- 新元素一律先插入到堆的尾部
	- 依次向上调整整个堆的结构（一直到根即可）
	- Delete Max 删除堆顶项操作

		- 将堆尾元素替换到顶部(即对顶被代替删除掉)
		- 依次从根部向下调整整个堆的结构(一直到堆尾即可)

## 图graph

## 递归

### 理解例子

- 从前有个山
- 盗梦空间

### 递归模板

### 思维要点

- 不要人肉进行递归(最大误区)
- 找到最近最简方法，将其拆解成可重复解决的问题(重复子问题)
- 数学归纳法思维

### 分治

- 重复性
- 分治代码模板

### 回溯

- 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。
- 实现

	- 递归

- 回溯模板=递归模板+恢复原状态

  result = []
  def backtrack(路径, 选择列表):
      if 满足结束条件:
          result.add(路径)
          return
      for 选择 in 选择列表:
          做选择(是否已经选过了)
          backtrack(路径, 选择列表)
          撤销选择

### DFS(深度优先遍历)

DFS模板跟递归模板类似

public void dfs(TreeNode root) {
      //1. 递归终止条件判断    
    if(root == null) return null;
    //2. 本层逻辑处理  
        result.add(root.val);
    //3.  跳转到下一层
        dfs(root.left,result);
        dfs(root.right,result);
    //4. 本层数据状态重置
}

### BFS(广度优先遍历)

public void bfs(TreeNode root) {
        //边界条件判断
        if (root == null) {
            return ret;
        }
        //声明存储节点的queue 先进先出
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        //将第一个节点入队
        queue.offer(root);
        //如果处理当前层的队列,不为空时
        while (!queue.isEmpty()) {
            //出队并对node做处理
            TreeNode node = queue.poll();
            //将下一层左子树的元素存入队列
            if (node.left != null) {
                queue.offer(node.left);
            }
            //将下一层右子树的元素存入队列
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }

## 贪心算法

### 贪心算法是在每一步都找到局部最优解从而是整体到达最优解

对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案,一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心
法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题

### 与动态规划的区别: 它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

### 解决的常见问题: 图中的最小生成树、求哈夫曼编码等

### 适用场景

- 简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构

## 二分法

### 使用前提

- 目标函数单调性(单调递增或递减)
- 存在上下界
- 能够通过索引访问

### 算法模板

public boolean dichotomy(int[] nums,int target){
    int left =0;
    int right = nums.length-1;
    while (left<=right){
        int mid = (left+right)/2;
        if (nums[mid]==target){
            return true;
        }else if(nums[mid]<target){
            left = mid+1;
        }else {
            right=mid-1;
        }
    }
    return false;
}

### 注意点

- 边界条件的判断

*@zf*